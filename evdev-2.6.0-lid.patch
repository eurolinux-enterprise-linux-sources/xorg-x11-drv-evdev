From ec96e41fb0835ea8ffb2c430ca623ace032726f7 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 30 Jun 2011 14:19:28 +1000
Subject: [PATCH] Re-scan RANDR info on lid switches (#618845).

Scan for lid switch devices, translate events on them into RANDR rescans so
the desktop will pick them up.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
---
 src/evdev.c |   65 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 65 insertions(+), 0 deletions(-)

diff --git a/src/evdev.c b/src/evdev.c
index 45873c1..77b19cf 100644
--- a/src/evdev.c
+++ b/src/evdev.c
@@ -35,6 +35,7 @@
 
 #include <X11/keysym.h>
 #include <X11/extensions/XI.h>
+#include <X11/Xdefs.h>
 
 #include <linux/version.h>
 #include <sys/stat.h>
@@ -823,9 +824,43 @@ EvdevProcessSyncEvent(InputInfoPtr pInfo, struct input_event *ev)
 
 }
 
+/* Switch events must be called through a BlockHandler, we can't call
+ * RRGetInfo during the SIGIO handler */
+extern void RRGetInfo(ScreenPtr, int);
+static int lid_event;
+
+static void
+EvdevProcessSwitchEvent(InputInfoPtr pInfo, struct input_event *ev)
+{
+    if (ev->code == SW_LID)
+        lid_event = 1;
+}
+
+/* yes, the block/unblock is necessary */
+static void
+EvdevBlockHandler(pointer block, OSTimePtr timeout, pointer readmask)
+{
+    if (lid_event) {
+        int i, wasset;
+        wasset = xf86BlockSIGIO();
+        for (i = 0; i < screenInfo.numScreens; i++)
+            RRGetInfo(screenInfo.screens[i], TRUE);
+        lid_event = 0;
+        xf86UnblockSIGIO(wasset);
+    }
+}
+
+static void
+EvdevWakeupHandler(void *block, int res, void *readmask)
+{
+}
+
 /**
  * Process the events from the device; nothing is actually posted to the server
  * until an EV_SYN event is received.
+ *
+ * ... except for switch events, because they're magic things that X apps
+ * never see.
  */
 static void
 EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
@@ -840,6 +875,9 @@ EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
         case EV_KEY:
             EvdevProcessKeyEvent(pInfo, ev);
             break;
+        case EV_SW:
+            EvdevProcessSwitchEvent(pInfo, ev);
+            break;
         case EV_SYN:
             EvdevProcessSyncEvent(pInfo, ev);
             break;
@@ -1890,6 +1928,7 @@ EvdevProbe(InputInfoPtr pInfo)
 {
     int i, has_rel_axes, has_abs_axes, has_keys, num_buttons, has_scroll;
     int has_lmr; /* left middle right */
+    int has_switch;
     int ignore_abs = 0, ignore_rel = 0;
     EvdevPtr pEvdev = pInfo->private;
     int rc = 1;
@@ -1920,8 +1959,29 @@ EvdevProbe(InputInfoPtr pInfo)
     has_keys = FALSE;
     has_scroll = FALSE;
     has_lmr = FALSE;
+    has_switch = FALSE;
     num_buttons = 0;
 
+    if (TestBit(EV_SW, pEvdev->bitmask)) do {
+        unsigned long sw_bitmask[NLONGS(SW_CNT)];
+        int len;
+
+        len = ioctl(pInfo->fd, EVIOCGBIT(EV_SW, sizeof(sw_bitmask)),
+                    sw_bitmask);
+
+        if (len < 0) {
+            xf86Msg(X_ERROR, "%s: ioctl EVIOCGBIT failed: %s\n",
+                    pInfo->name, strerror(errno));
+            break;
+        }
+
+        if (!TestBit(SW_LID, sw_bitmask))
+            break;
+
+        xf86Msg(X_INFO, "%s: Adding for lid switch\n", pInfo->name);
+        has_switch = TRUE;
+    } while (0);
+
     /* count all buttons */
     for (i = BTN_MISC; i < BTN_JOYSTICK; i++)
     {
@@ -2096,6 +2156,11 @@ EvdevProbe(InputInfoPtr pInfo)
         xf86Msg(X_WARNING, "%s: Don't know how to use device\n",
 		pInfo->name);
 
+    if (has_switch)
+        /* ! is intentional, return codes are the other way around */
+        rc = !RegisterBlockAndWakeupHandlers(EvdevBlockHandler,
+                                             EvdevWakeupHandler,
+                                             NULL);
     return rc;
 }
 
-- 
1.7.5.4

