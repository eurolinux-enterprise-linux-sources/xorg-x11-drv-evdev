From b7358946467fa2906920afec826f788f0477d793 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 30 Jun 2011 14:19:28 +1000
Subject: [PATCH evdev] Re-scan RANDR info on lid switches (#618845).

Scan for lid switch devices, translate events on them into RANDR rescans so
the desktop will pick them up.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
---
 src/evdev.c | 65 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 65 insertions(+)

diff --git a/src/evdev.c b/src/evdev.c
index 54772c7..34c2d11 100644
--- a/src/evdev.c
+++ b/src/evdev.c
@@ -35,6 +35,7 @@
 
 #include <X11/keysym.h>
 #include <X11/extensions/XI.h>
+#include <X11/Xdefs.h>
 
 #include <linux/version.h>
 #include <sys/stat.h>
@@ -1032,9 +1033,43 @@ EvdevProcessSyncEvent(InputInfoPtr pInfo, struct input_event *ev)
 
 }
 
+/* Switch events must be called through a BlockHandler, we can't call
+ * RRGetInfo during the SIGIO handler */
+extern void RRGetInfo(ScreenPtr, int);
+static int lid_event;
+
+static void
+EvdevProcessSwitchEvent(InputInfoPtr pInfo, struct input_event *ev)
+{
+    if (ev->code == SW_LID)
+        lid_event = 1;
+}
+
+/* yes, the block/unblock is necessary */
+static void
+EvdevBlockHandler(pointer block, OSTimePtr timeout, pointer readmask)
+{
+    if (lid_event) {
+        int i, wasset;
+        wasset = xf86BlockSIGIO();
+        for (i = 0; i < screenInfo.numScreens; i++)
+            RRGetInfo(screenInfo.screens[i], TRUE);
+        lid_event = 0;
+        xf86UnblockSIGIO(wasset);
+    }
+}
+
+static void
+EvdevWakeupHandler(void *block, int res, void *readmask)
+{
+}
+
 /**
  * Process the events from the device; nothing is actually posted to the server
  * until an EV_SYN event is received.
+ *
+ * ... except for switch events, because they're magic things that X apps
+ * never see.
  */
 static void
 EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
@@ -1049,6 +1084,9 @@ EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
         case EV_KEY:
             EvdevProcessKeyEvent(pInfo, ev);
             break;
+        case EV_SW:
+            EvdevProcessSwitchEvent(pInfo, ev);
+            break;
         case EV_SYN:
             EvdevProcessSyncEvent(pInfo, ev);
             break;
@@ -2057,6 +2095,7 @@ EvdevProbe(InputInfoPtr pInfo)
     int i, has_rel_axes, has_abs_axes, has_keys, num_buttons, has_scroll;
     int has_lmr; /* left middle right */
     int has_mt; /* multitouch */
+    int has_switch;
     int ignore_abs = 0, ignore_rel = 0;
     EvdevPtr pEvdev = pInfo->private;
     int rc = 1;
@@ -2091,8 +2130,29 @@ EvdevProbe(InputInfoPtr pInfo)
     has_scroll = FALSE;
     has_lmr = FALSE;
     has_mt = FALSE;
+    has_switch = FALSE;
     num_buttons = 0;
 
+    if (EvdevBitIsSet(pEvdev->bitmask, EV_SW)) do {
+        unsigned long sw_bitmask[NLONGS(SW_CNT)];
+        int len;
+
+        len = ioctl(pInfo->fd, EVIOCGBIT(EV_SW, sizeof(sw_bitmask)),
+                    sw_bitmask);
+
+        if (len < 0) {
+            xf86Msg(X_ERROR, "%s: ioctl EVIOCGBIT failed: %s\n",
+                    pInfo->name, strerror(errno));
+            break;
+        }
+
+        if (!EvdevBitIsSet(sw_bitmask, SW_LID))
+            break;
+
+        xf86Msg(X_INFO, "%s: Adding for lid switch\n", pInfo->name);
+        has_switch = TRUE;
+    } while (0);
+
     /* count all buttons */
     for (i = BTN_MISC; i < BTN_JOYSTICK; i++)
     {
@@ -2296,6 +2356,11 @@ EvdevProbe(InputInfoPtr pInfo)
     if (rc)
         xf86IDrvMsg(pInfo, X_WARNING, "Don't know how to use device\n");
 
+    if (has_switch)
+        /* ! is intentional, return codes are the other way around */
+        rc = !RegisterBlockAndWakeupHandlers(EvdevBlockHandler,
+                                             EvdevWakeupHandler,
+                                             NULL);
     return rc;
 }
 
-- 
1.7.11.2

