From 0ca65f3b8c10a592335187c758e033c10ad1d5c4 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 30 Jun 2011 14:19:28 +1000
Subject: [PATCH evdev 1/4] Re-scan RANDR info on lid switches (#618845).

Scan for lid switch devices, translate events on them into RANDR rescans so
the desktop will pick them up.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
---
 src/evdev.c | 65 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 65 insertions(+)

diff --git a/src/evdev.c b/src/evdev.c
index af4aba3..87a2cf4 100644
--- a/src/evdev.c
+++ b/src/evdev.c
@@ -36,6 +36,7 @@
 
 #include <X11/keysym.h>
 #include <X11/extensions/XI.h>
+#include <X11/Xdefs.h>
 
 #include <linux/version.h>
 #include <sys/stat.h>
@@ -1045,9 +1046,43 @@ EvdevProcessSyncEvent(InputInfoPtr pInfo, struct input_event *ev)
 
 }
 
+/* Switch events must be called through a BlockHandler, we can't call
+ * RRGetInfo during the SIGIO handler */
+extern void RRGetInfo(ScreenPtr, int);
+static int lid_event;
+
+static void
+EvdevProcessSwitchEvent(InputInfoPtr pInfo, struct input_event *ev)
+{
+    if (ev->code == SW_LID)
+        lid_event = 1;
+}
+
+/* yes, the block/unblock is necessary */
+static void
+EvdevBlockHandler(pointer block, OSTimePtr timeout, pointer readmask)
+{
+    if (lid_event) {
+        int i, wasset;
+        wasset = xf86BlockSIGIO();
+        for (i = 0; i < screenInfo.numScreens; i++)
+            RRGetInfo(screenInfo.screens[i], TRUE);
+        lid_event = 0;
+        xf86UnblockSIGIO(wasset);
+    }
+}
+
+static void
+EvdevWakeupHandler(void *block, int res, void *readmask)
+{
+}
+
 /**
  * Process the events from the device; nothing is actually posted to the server
  * until an EV_SYN event is received.
+ *
+ * ... except for switch events, because they're magic things that X apps
+ * never see.
  */
 static void
 EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
@@ -1062,6 +1097,9 @@ EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
         case EV_KEY:
             EvdevProcessKeyEvent(pInfo, ev);
             break;
+        case EV_SW:
+            EvdevProcessSwitchEvent(pInfo, ev);
+            break;
         case EV_SYN:
             EvdevProcessSyncEvent(pInfo, ev);
             break;
@@ -2126,6 +2164,7 @@ EvdevProbe(InputInfoPtr pInfo)
     int i, has_rel_axes, has_abs_axes, has_keys, num_buttons, has_scroll;
     int has_lmr; /* left middle right */
     int has_mt; /* multitouch */
+    int has_switch;
     int ignore_abs = 0, ignore_rel = 0;
     EvdevPtr pEvdev = pInfo->private;
     int rc = 1;
@@ -2166,8 +2205,14 @@ EvdevProbe(InputInfoPtr pInfo)
     has_scroll = FALSE;
     has_lmr = FALSE;
     has_mt = FALSE;
+    has_switch = FALSE;
     num_buttons = 0;
 
+    if (libevdev_has_event_code(pEvdev->dev, EV_SW, SW_LID)) {
+        xf86Msg(X_INFO, "%s: Adding for lid switch\n", pInfo->name);
+        has_switch = TRUE;
+    } while (0);
+
     /* count all buttons */
     for (i = BTN_MISC; i < BTN_JOYSTICK; i++)
     {
@@ -2378,6 +2438,11 @@ out:
     if (rc)
         xf86IDrvMsg(pInfo, X_WARNING, "Don't know how to use device\n");
 
+    if (has_switch)
+        /* ! is intentional, return codes are the other way around */
+        rc = !RegisterBlockAndWakeupHandlers(EvdevBlockHandler,
+                                             EvdevWakeupHandler,
+                                             NULL);
     return rc;
 }
 
-- 
1.9.0

